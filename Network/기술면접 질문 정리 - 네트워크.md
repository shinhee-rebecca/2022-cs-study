# TL;DR

### 네트워크

- 네트워크의 정의 / 종류
- `WEB` 과 WEB `브라우저` 정의
- 웹 서버와 `WAS` 차이점

- `API` 란?

<br>

### HTTP

- HTTP `Method` / `상태코드` / `Vesrion`

- `HTTPS` => (SSL)

- `쿠키` vs `세션` vs `JWT`

- 웹 `캐시` / 웹 스토리지

- `REST API`

<br>

### OSI 7계층

- `TCP/IP 4계층`
- `TCP`와 `UDP`
- `비동기`와 `동기` / `Blocking` 과 `Non-blocking`

<br><br><br>

# **네트워크**

### 네트워크란?

네트워크란 물리적 전송 매체를 사용해 서로 연결된 장치 집합으로 정의됩니다. 예를 들어 컴퓨터 네트워크는 하드웨어, 데이터 및 소프트웨어와 같은 정보와 리소스를 통신하고 공유하기 위해 서로 연결된 컴퓨터 그룹입니다.

<br>

#### **네트워크의 종류는?**

LAN, WAN, 인터넷이 있습니다.

- LAN(인트라넷)은 비교적 좁은 공간인 학교, 기업, 연구소 등의 컴퓨터 끼리 이어 구성한 네트워크를 말하고, 구리선을 짜넣은 LAN 케이블을 사용한다.
- WAN은 지리적으로 떨어져 있는 기기 끼리 연결한 비교적 대규모의 네트워크를 말하며, 광섬유 케이블이나, 회선을 이용한다.
- 인터넷이란 LAN, WAN을 연결한 전세계 규모의 네트워크이다.

<br>

#### **네트워크를 통해 전송되는 데이터는 어떤 방식으로 표현되나요?**

텍스트, 오디오, 비디오, 이미지, 숫자 등과 같은 다양한 방식으로 제공됩니다.

<br>

#### **네트워크는 연결에 따라 어떻게 분류되나요?**

연결 유형에 다라 두 가지 범주로 분류됩니다.

- **피어 투 피어 네트워크 (P2P) :** 중앙 서버를 사용하지 않고 리소스를 공유하기 위해 두 대 이상의 컴퓨터가 함께 연결되어있는 경우 피어-투-피어 네트워크라고합니다. 이러한 유형의 네트워크에있는 컴퓨터는 서버와 클라이언트로 작동합니다. 비싸지 않기 때문에 일반적으로 소규모 회사에서 사용됩니다.
- **서버 기반 네트워크 :** 이러한 유형의 네트워크에서 중앙 서버는 클라이언트의 데이터, 응용 프로그램 등을 저장하기 위해 위치합니다. 서버 컴퓨터는 네트워크에 보안 및 네트워크 관리를 제공합니다.

<br><br>

### **WEB 이란?**

WEB은 World Wide Web의 약자로 **인터넷이라는 서비스 체계 위에서 동작하는 서비스 중에 하나**입니다. **인터넷에 연결된 컴퓨터를 이용해 사람들과 정보를 공유할 수 있는 거미줄(Web)처럼 얼기설기 엮인 공간을 뜻하는 용어입니다.**

<br>

### WEB 브라우저란?

**HTML 문서와 그림, 멀티미디어 파일 등 WWW을 기반으로 한 인터넷의 콘텐츠를 검색 및 열람하기 위한 응용프로그램의 총칭.**

<br>

### 브라우저는 어떻게 구성되어 있나요?

![웹 브라우저 구성](https://camo.githubusercontent.com/0e3ac4e617b8eda5046f592c74a1f7e4cbfb82a5c6abe8d5699020002c1227b6/68747470733a2f2f64322e6e617665722e636f6d2f636f6e74656e742f696d616765732f323031352f30362f68656c6c6f776f726c642d35393336312d312e706e67)

<br><br>

### **웹 서버와 웹 어플리케이션 서버(WAS)의 차이는?**

웹 서버는 정적 콘텐츠만 제공하고 웹 어플리케이션 서버는 비즈니스 로직 처리, DB접속, 트랜잭션 등을 통해 동적인 콘텐츠를 제공합니다.

<br><br>

### API란?

- API(Application Programming Interface)는 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.
- API는 두 응용 프로그램이 서로 통신할 수 있도록 하는 **소프트웨어 중재자**

<br><br><br>

# **HTTP 프로토콜**

### HTTP 프로토콜이란?

HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다. HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다.

<br>

#### HTTP 프로토콜의 장단점은?

- 장점
  - 통신간의 연결 상태 처리나 상태 정보를 관리할 필요가 없어 서버 디자인이 간단하다.
  - 각각의 HTTP 요청에 독립적으로 응답만 보내주면 OK
- 단점
  - 이전 통신의 정보를 모르기 때문에 매번 인증을 해줘야 한다.
  - 이를 해결하기 위해 쿠키(cookie)나 세션(session)을 사용해서 데이터를 처리한다.

<br>

### 왜 웹 서비스 구조는 Stateless 기반을 따를까?

Stateless 구조는 Scaling이 자유롭다는 큰 이점을 가지고 있기 때문입니다.

트래픽의 급증으로 서버가 scale out 되었을 때, Stateful 서비스는 클라이언트의 정보를 모두 옮겨야 하는 부수적인 관리가 요구되는데 반해 Stateless 서비스는 그런 걱정이 없기 때문입니다.

<br><br>

## **1) HTTP Metohd & 상태코드**

### **HTTP Method 와 각각이 사용되는 경우**

HTTP 메소드는 클라이언트가 서버에게 사용자 요청의 목적을 알리는 '수단'입니다.

- GET은 데이터 조회, POST는 요청 데이터 처리(보통 등록에 사용), PUT은 데이터 변경(해당 데이터 없으면 생성), PATCH는 일부 데이터만 변경, DELETE는 데이터 삭제를 위해 사용합니다.

<br>

#### **PUT과 PATCH 차이**

두 메서드 요청 둘 다, 리소스의 업데이트를 한다는 점에서 같지만 PUT은 리소스 모든 것을 업데이트 하지만, PATCH는 리소스 일부를 업데이트 합니다.

<br>

#### **GET과 POST의 차이**

사용 목적, 요청에 body 유무 그리고 멱등성 관점에서 이야기할 수 있습니다.

먼저 GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성 또는 업데이터 할 때 사용합니다.

그리고 GET은 URL 파라미터에 요청하는 데이터를 담아 보내므로 HTTP 메세지에 body가 없지만 POST는 body에 데이터를 담아 보냅니다.

마지막으로 GET은 리소스를 조회한다는 점에서 여러 번 요청해도 응답이 같아 멱등이지만 POST는 리소스 생성/업데이트 용도라 멱등이 아닙니다.

- GET은 URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다. POST는 완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.

<br>

#### **완전히 안전하게 하려면 어떻게 해야할까요?**

HTTP에 암호화가 추가된 프로토콜인 HTTPS를 사용해서 데이터를 암호화할 수 있습니다.

<br><br>

### HTTP 버전별 특징과 어떻게 개선되어 왔는지 설명해주세요.

HTTP 1.1 은 Pipelining이 특징이다. 기본적으로 HTTP 요청은 순차적이기 때문에 요청에 대한 응답을 받고 나서야 새로운 요청을 보낸다. 하지만 HTTP 1.1 에서는 응답을 기다리지 않고 요청을 연속적으로 보내는 기능이 추가되었다. 하나의 connection에서 한 번에 순차적인 여러 요청을 보내고 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄인다.

HTTP 2.0 은 Multiplexed Streams가 특징이다. HTTP 1.1 에서는 요청의 순서와 응답의 순서는 동기화 되어야 하므로 특정 요청을 처리하는데 많은 시간이 걸린다면 그 뒤의 다른 요청을 처리하는데 지연이 발생하여 HOL Blocking 이 발생한다. HTTP 2.0 은 하나의 Connection으로 동시에 여러 개의 메세지를 주고 받을 수 있다. 응답은 요청 순서에 상관없이 Stream 으로 받기 때문에 HOL Blocking 발생이 줄어든다.

HTTP 3.0은 TCP가 아닌 UDP를 사용한다는 것이다. HTTP 3.0 은 QUIC라는 프로토콜 위에서 돌아가는 HTTP인데, QUIC은 UDP를 사용하는 프로토콜이다. 그리고 TCP hand shake 과정을 최적화하는 것에 초점을 맞추어 설계되었다. UDP는 TCP에 비해 헤더가 많이 비어있기에, 커스터마이징할 수 있는 여지가 많고 이를 이용해 개발자가 구현을 어떻게 하느냐에 따라서 신뢰성을 확보할 수 있다.

<br>

### HTTP 상태코드에 대해 설명해주세요

<br><br>

## 2) HTTPS

### **HTTP와 HTTPS의 차이점은 무엇인가요?**

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다.  이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.

<br>

#### **HTTP와 HTTPS의 통신 방식의 차이는?**

HTTP는 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신함으로써 암호화와 증명서, 안전성 보호를 이용할 수 있게 됩니다.

<br>

### SSL은 어떻게 통신하나요?

<br>

### **SSL 인증서 암호화 기법은 무엇인가요?**

SSL의 암호화 방식에는 대칭키 방식과 공개키 방식을 적절히 혼용해 사용합니다.

- 먼저, 대칭키 방식은 암호화하고 복호화하는데 동일한 1개의 key를 사용합니다. 서버와 브라우저가 동일한 key 사용으로 외부 노출 시 보안에 취약해진다는 점이 있습니다.
- 공개키 방식은 2개의 key를 만들어, 하나는 나(서버)만 갖고(비밀키), 다른 하나는 모두(브라우저)에게 나눠줍니다.(공개키) '공개키'로 암호화한 것은 '비밀키'로 복호화할 수 있고, '비밀키'로 암호화한 건 '공개키'로 복호화할 수 있습니다.

<br>

### SSL은 왜 대칭키와 공개키 암호화 방식을 혼합해서 사용할까요?

<br>

### **인증기관 CA를 통한 인증을 하는 이유는 무엇인가요?**

<br>

### **왜 아직도 HTTP를 사용하는 웹사이트가 있을까요? (HTTPS의 단점)**

암호화를 추가함으로써 추가적인 오버로드와 비용이 추가되는데, 암호화가 필요 없는 데이터를 전송하는 경우도 존재하기 때문입니다.

<br><br>

## **3) 쿠키/세션/토큰**

### **HTTP의 무상태와 비연결성에 대해 설명해주세요**

**무상태성**은 연결을 끊는 순간 클라이언트와 서버의 통신이 종료되며 **상태 정보는 유지하지 않는 것**이고,비연결성이란 요청과 응답을 받고 나면 세션을 끊어버리는 것입니다.

두 특징으로 인해 리소스 낭비가 줄어든다는 장점이 있지만 매 통신마다 새로운 세션을 열어야 하고 요청 시마다 인증해야 한다는 단점이 생겼습니다.

<br>

### HTTP를 사용할 때 서버는 클라이언트의 정보를 저장하지 않는데, 어떻게 자동 로그인이나 장바구니 기능을 사용할 수 있을까요?

<br>

### **쿠키와 세션의 차이점**

쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있습니다. 세션은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 합니다.

<br>

### 인터넷 쇼핑을 할 때, 쿠팡에서 시리얼을 보고 나면 SNS에서도 시리얼 광고가 나오는데 이건 어떻게 가능한 일일까요?

`Third-Party 쿠키`

<br><br>

### 쿠키를 사용하게 될 때 예상되는 보안 문제가 있나요?

쿠키는 클라이언트 로컬에 저장되기도 하고 특히 파일로 저장되는 경우 탈취, 변조될 위험이 있어 보안이 비교적 취약합니다. 공용 PC에서 쿠키값이 유출될 수 있고, XSS (Cross Site Scripting)나 XSRF (Cross Site Request Forgery) 같은 공격에 취약합니다.

<br>

#### **XSS 와 XSRF란?**

- XSS (Cross Site Scripting)은 공격자가 웹 사이트에 악성 스크립트를 주입해 사용자 브라우저에서 악성 스크립트를 실행시키는 공격이고,
- XSRF (Cross Site Request Forgery)는 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위(수정, 삭제 등)를 특정 웹사이트에 요청하게 하는 공격입니다.

<br>

#### **해당 문제에 대한 해결책은?**

기본적으로 사용자가 쿠키를 잘 관리해야 하고, 쿠키 내에는 웹 공격에 대응하기 위해 XSS를 대비한 HttpOnly 옵션과 XSRF를 대비한 Samesite 옵션이 있습니다.

HttpOnly 옵션은 쿠키를 서버에 전송하는 용도로만 사용할 수 있도록 지정함으로써 자바스크립트 같은 외부 프로그램이 접근할 수 없도록 막는 것이고, SameSite 옵션은 Cross-Site 요청이 들어올 때 쿠키를 포함하지 않도록 막는 방법입니다.

<br>

### **많은 단점에도 굳이 쿠키를 사용하는 이유는?**

세션은 서버에 데이터를 저장, 즉 서버의 자원을 사용하기 때문에 서버 자원에 한계가 있고 메모리를 사용하다 보면 속도 저하도 올 수 있기 때문입니다. 특히 쿠키는 Load Balancing이 필요할 때 큰 역할을 할 수 있습니다.

<br><br>

### **세션 기반 인증과 토큰 기반 인증의 차이**

세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고, 토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.

<br>

#### Stateful한 세션 기반의 인증 방식을 사용하게 된다면 어떤 단점이 있을까요?

1. 서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮습니다.
2. 해커가 훔친 쿠키를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다. (세션 하이재킹 공격)

<br>

#### **그렇다면 세션 기반 인증과 토큰 기반 인증은 각각 어느 경우에 적합한가요?**

단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각합니다. 왜? - 세션을 관리할 때 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것은 어렵습니다. (CORS 문제)

<br><br>

### **JWT 토큰에 대해 설명해주세요**

JWT는 JSON 포맷을 이용하는 Claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달합니다. JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.

- 헤더(Header) : 토큰의 타입과 해시 암호화 알고리즘(방식지정)으로 이루어져 있다.
- 내용(Payload) : 토큰에 사용자가 담고자 하는 정보를 담는다. 내용에는 Claim이 담겨있고, JSON(Key/Value)형태의 한 쌍으로 이루어져 있다.
- 서명(Signature) : 토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.

<br>

#### JWT 토큰의 단점과 해결방법

Refresh Token

<br>

### **Refresh Token을 사용한다고 가정하고, 네이버 블로그의 Access token의 유효기간이 1시간이면 글을 작성하다 1시간이 지나서 글을 발행할 때 오류가 발생할텐데 이 문제는 어떻게 해결할 수 있을까요?**

일정 시간마다 새로운 Access Token을 발급 받는 설정을 추가할 수 있습니다. Access Token의 만료 기간이 1시간이라면 55분 정도에 새로운 token을 발급 받도록 해서 사용자가 Access token이 만료되었다는 사실을 모르게 연장시킬 수 있습니다.

<br>

### **Refresh Token을 프론트 서버의 세션과 백엔드 서버 중 어디에 저장해야 될까요?**

둘 다 장단점이 존재한다고 생각합니다.

**1) 프론트 서버의 세션에 저장하는 경우**

Refresh token을 프론트 서버의 세션에 저장하면 클라이언트가 토큰이 저장된 세션에 접근하기 위해 Session ID를 쿠키로 가지고 있어야 합니다.

이 경우 새로 고침 상황에서  access token을 얻기 위해 벡엔드 서버로 요청을 보낼 필요가 없어 경제적입니다. 하지만 사용자가 많아질 수록 세션 관리가 힘들어질 수 있다는 단점이 있습니다.

**2) 백엔드 서버에 저장하는 경우**

Refresh token을 벡엔드 서버에 저장하면 새로 고침했을 때 Access token을 얻기위해 백엔드 서버를 거쳐야 해서 비용이 더 들게 됩니다. 하지만 사용자가 많아짐에 따라 생기는 서버 이슈가 프론트, 벡엔드로 나뉘지 않고 백엔드에서 대부분 처리하기 때문에 관리에 용이하다는 장점이 있습니다.

<br>

### **만약 Refresh Token이 탈취 당해 해커가 Refresh Token을 이용해 새로운 Access Token을 요청할 수 있지 않나요? 보안에 취약한 것 아닌가요?**

Refresh Token은 클라이언트와 서버 두 곳에 저장됩니다. 만약 Refresh Token이 탈취되어 해커가 새로운 Access Token을 발급한다면 서버는 다른 나라의 IP주소로 요청이 들어왔다거나 하는 검증 작업을 통해 요청을 거절하고 Refresh Token을 서버에서 지워버려 Access Token을 해커에게 발급하지 않을 수 있습니다. 즉, Refresh Token은 서버가 해킹된 토큰에 대한 방어 행동을 취할 수 있게 해주는 도구가 됩니다.

그리고 Access token과 Refresh Token은 보안성뿐 아니라 성능과 사용 편의성 등을 적절하게 타협한 결과입니다. 보안만 추구한다면 더 좋은 방법들이 있을 것입니다.

<br><br>

## **4) 캐시**

### 한 번 들어갔던 웹사이트는 다음에 더 빠르게 로딩이 되는데 왜 그럴까요?

웹 캐시

<br>

### 캐시를 사용하면 콘텐츠가 변했을 때 새로운 것을 받아오기 어려울 것 같은데 어떻게 해결할 수 있을까요?

<br>

### **브라우저 저장소에 대해 설명해주세요**

Web Storage란 HTML5부터 제공하는 기능으로, **해당 도메인과 관련된 특정 데이터를** 서버가 아니라 **클라이언트 웹브라우저에 저장**할 수 있도록 제공하는 기능으로 쿠키(cookie)와 비슷한 기능입니다.

Web Storage의 개념은 **키/값** 쌍으로 데이터를 저장하고, **키를 기반으로 데이터를 조회**하는 패턴입니다. **영구저장소(LocalStorage)**와 **임시저장소(SessionStorage)**를 따로 두어 **데이터의 지속성을 구분**할 수 있어 응용 환경에 맞는 선택이 가능합니다.

<br>

#### 브라우저 저장소 왜 사용하나요?

쿠키의 단점을 Web Storage를 사용함으로써 극복할 수 있습니다.

- 쿠키는 4KB의 데이터 저장 제한
- HTTP Request에 암호화되지 않은 상태로 사용하기 때문에 보안에 취약
- 쿠키는 모든 HTTP Request에 포함되어 있어 웹서비스 성능에 영향을 줄 수 있음

<br><br>

## 5**) REST API**

### REST API란?

- HTTP를 통해 자원을 주고 받을 때 HTTP URI를 통해 자원을 명시하고 HTTP Method를 통해 자원의 CRUD를 수행하는 것을 말합니다.
- **REST API**란 이런 **REST 기반으로 서비스 API를 구현**한 것입니다.
- REST API는 HTTP 표준 기반이므로
  1. HTTP 지원 프로그램 언어로 클라이언트, 서버를 구현할 수 있으며,
  2. REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 합니다.

<br>

### REST API를 사용하는 이유는?

클라이언트의 형태가 다양하더라도 HTTP 브라우저만 있으면 데이터를 주고받을 수 있기 때문입니다. REST API를 이용하면 멀티 플랫폼 환경에서 빠르게 확장이 가능하기 때문에 사용합니다.

<br>

### **REST API에는 설계 규칙이 있고, 흔히 REST API를 제공하는 웹 서비스를 'RESTful' 하다고 하는데 설계 규칙에는 어떤게 있을까요?**

- URL은 정보의 자원을 표현해야 하는데, 리소스는 동사보다는 명사를, 대문자보다는 소문자를 사용해야 하는 내용이 있고
- 자원에 대한 행위는 HTTP Method(get, put, post, delete 등)로 표현하는데, URL엔 HTTP Method, 동사 표현이 들어가면 안 되며, 경로 부분 중 변하는 부분은 유일한 값으로 대체해야 합니다.
- 슬래시 구분자는 계층 관계를 나타내며 마지막 문자로 슬래시를 포함하지 않습니다.
- 불가피하게 경로가 길어지면 하이픈을 사용하여 가독성을 높입니다.
- URL 경로엔 소문자를 사용합니다.
- 파일 확장자는 포함하지 않습니다.

<br>

### **자바스크립트에서 HTTP Request를 동기로 호출하고 값을 처리하면 발생하는 문제점은?**

Request에 대한 Response 응답시간이 길어질 수도 있으므로 절차 지향적으로 짜놓은 코드가 제 대로 동작하지 않을 수 있습니다.

<br>

#### 해결책은?

CallBack 함수를 만들어 호출하면 해당 Request에 대한 응답이 온 후에 이후에 그 값을 가지고 다시 다른 함수를 실행합니다.

<br>

### **콜백함수의 문제점과 해결방안은?**

콜백함수를 이용한 비동기처리를 많이 하면 ‘콜백헬’이라 불리는 가독성이 매우 떨어지는 코드가 됩니다. 가독성 저하는 유지보수에 걸림돌이 되므로, Promise나 Async/Await을 사용합니다. Promise에서는 요청 후 비동기 처리하는 부분은 then절에 추가하면 되고 Async/Await는 Await이 then절의 역할을 합니다.

<br><br>

## 6**) 보안/인증**

### **CORS(Cross-Origin Resource Sharing)는 무엇인가? 왜 이러한 방법이 정의되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가요?**

CORS는 도메인이 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제입니다.

CORS가 생기게 된 이유는 서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해서인데, 요청을 하락하기 위해서는 Access-Control-Allow-Origin 내용을 Response 헤더에 추가해야 합니다.

<br>

### **세션과 쿠키 그리고 토큰의 인증 방식 차이는?**

- 세션 쿠키 방식의 인증은 기본적으로 **세션 저장소를 필요**로 합니다.

  1. 세션 저장소는 로그인을 했을 때 사용자의 정보를 저장하고 열쇠가 되는 세션 ID값을 만듭니다.
  2. 그리고 HTTP 헤더에 실어 사용자에게 돌려보냅니다.
  3. 그러면 사용자는 쿠키로 보관하고 있다 인증이 필요한 요청에 쿠키(세션 ID)를 넣어 보낼 것입니다. 웹 서버에서는 세션 저장소에서 쿠키(세션 ID)를 받고 저장되어 있는 정보와 매칭 시켜 인증을 완료합니다.

- **쿠키만으로 인증을 사용한다는 말은 서버의 자원은 사용하지 않는다는 것이며, 이는 즉 클라이언트가 인증 정보를 책임지게 됩니다.** 그렇게 되면 위의 첫 번째 방식처럼 HTTP 요청을 탈취당할 경우 다 털리게 됩니다. 따라서 보안과는 상관없는 단순히 장바구니나 자동 로그인 설정 같은 경우에는 유용하게 쓰입니다.

- **JWT는 세션/쿠키와 함께 모바일과 웹의 인증을 책임지는 대표주자**입니다. JWT는 Json Web Token의 약자로 **인증에 필요한 정보들을 암호화시킨 토큰**을 뜻합니다. 위의 세션/쿠키 방식과 유사하게 사용자는 Access Token(JWT 토큰)을 HTTP 헤더에 실어 서버로 보내게 됩니다.

- **세션/쿠키 방식과 가장 큰 차이점**은 세션/쿠키는 **세션 저장소**에 유저의 정보를 넣는 반면,

  JWT는 **토큰** 안에 유저의 정보들이 넣는다는 점입니다.

- 물론 클라이언트 입장에서는 HTTP 헤더에 세션 ID나 토큰을 실어서 보내준다는 점에서는 동일하나, 서버 측에서는 인증을 위해 암호화를 하냐, 별도의 저장소를 이용하냐는 차이가 발생합니다.

<br>

### OAuth

인터넷 사용자들이 비밀번호를 제공하지 않고, 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수있는 개방형 표준 방법

구글, 페이스북, 트위터 등이 사용하고 있으며 타사 애플리케이션 및 웹사이트의 계정에 대한 정보를 공유할 수 있도록 허용해준다.

- How to process

1. 소비자가 서비스 제공자에게 요청토큰을 요청한다.
2. 서비스 제공자가 소비자에게 요청토큰을 발급해준다.
3. 소비자가 사용자를 서비스제공자로 이동시킨다. 여기서 사용자 인증이 수행된다.
4. 서비스 제공자가 사용자를 소비자로 이동시킨다.
5. 소비자가 접근토큰을 요청한다.
6. 서비스제공자가 접근토큰을 발급한다.
7. 발급된 접근토큰을 이용해서 소비자에서 사용자 정보에 접근한다.

<br><br><br>

# **OSI 7 layer**

### OSI 7계층이란? 각 계층에 대한 설명

OSI 모델은 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것입니다.

- 7 계층(응용 계층) : 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할
- 6 계층(표현 계층) : 데이터의 형식(Format)을 정의하는 계층 (코드 간의 번역을 담당)
- 5 계층(세션 계층) : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
- 4 계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 :Segment) (ex. TCP, UDP)
- 3 계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 (단위 :Packet) (ex. Router)
- 2 계층(데이터링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층 (단위 :frame) (ex. 이더넷)
- 1 계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 :bit) (장비: 케이블,리피터,허브)

<br>

### 네트워크 방화벽이란?

네트워크 구간사이에 낮은 수준에서 오는 트래픽을 신뢰수준이 높은 네트워크로 못오게 벽을 세우는 것이다.

OSI 3계층, 4계층에서 동작해 패킷이 정상적이고 올바른건지 확인한다. 비정상적인 사용자의 접근을 막고, 불필요한 접근을 최소화하고, 네트워크 비용을 줄인다.

<br>

### 웹 방화벽이란?

OSI 7계층(어플리케이션 계층)에서 URL이 정상적인지 확인한다. 이걸로 손쉬운 세션과 로그관리를 할 수 있고, 개발자의 프로그램 상의 취약점을 보완하고 웹서버의 부하를 줄여준다.

<br><br>

### TCP/IP 프로토콜 4 계층에 대해 설명해주세요

- LINK 계층 : 물리적인 계층, LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의 하는 영역
- IP 계층 : 경로 검색을 해주는 계층으로 오류 발생하면 다른 임의의 경로로 변경해주는 프로토콜입니다.
- TCP/UDP(전송) 계층 : 데이터의 실제 송수신을 담당합니다. IP 계층에서 발생한 문제를 해결해주는 계층입니다.
- APPLICATION 계층 : 서버와 클라이언트를 만드는 과정에서 프로그램의 성격에 따라 정한 데이터 송수신에 대한 약속(규칙)

<br>

### **PORT란? 사용하는 이유?**

IP 주소의 한계 때문입니다.  IP Address만을 이용해 컴퓨터로 데이터를 보낸다면 컴퓨터는 그 데이터를 받지만, 문제는 그 데이터가 어**느 프로세스에서 처리되어야 하는 것인지를 알 수가 없습니다.**

통신을 해야하는 프로세스는 각자 자신의 Port를 가지고 있고, 해당 Port를 통해 데이터를 받습니다. 즉, PORT 정보를 통해 어떤 프로세스가 메세지를 받아야 하는지 구분할 수 있습니다.

<br><br>

### **TCP와 UDP 차이**

TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다. UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.

TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다.

<br>

### **3 way-handshaking와 4 way-handshaking 설명해주세요.**

3 way-handshake란 TCP 네트워크에서 통신 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인합니다. 4 way-handshake란 TCP 네트워크에서 통신 하는 장치의 연결을 해제하는 방법입니다. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 끊습니다.

<br>

### **왜 4 way-handshaking 을 사용하나요?**

여러 가지 비정상 종료 상황을 대비하기 위해서 입니다.

- 서버가 마지막에 FIN을 보내는 이유는

  서버가 아직 클라이언트에 보낼 데이터가 남아있을 경우 데이터를 다 전송하지도 못한 채 클라이언트 에서 포트를 닫아버리게 되므로 서버 또한 종료될 준비가 되었다는 의미로 FIN을 보냄

- 클라이언트가 마지막에 ACK를 굳이 보내는 이유는

  서버가 보낸 FIN을 클라이언트가 받지 못하면 클라이언트는 FIN_WAIT_2 상태로 종료가 되지 못한 채 계속 기다려야 한다. 하지만 서버는 이미 포트를 닫고 더는 응답을 하지 않는 상태이기에 클라이 언트는 불필요한 자원을 소모할 수 있음

<br>

### 혼잡 제어와 흐름제어란?

흐름제어는 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법으로 receiver가 sender에게 현재 자신의 상태를 feedback 함으로 제어합니다.

혼잡 제어는 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법입니다.

<br>

#### 흐름 제어는 어떤 상황에서 사용되나요? 그리고 그 방법은 무엇인가요?

흐름 제어는 수신측의 처리 속도가 송신측의 처리 속도보다 느리면 수신측의 버퍼 오버플로우가 발생하므로 이를 방지하기 위해 필요합니다.

수신측은 ACK를 보낼 때 TCP 헤더에 window size를 보내고, 송신측은 이 크기만큼 수신량을 정해 전달하는 방법으로 해결할 수 있습니다.

<br>

#### **혼잡 제어는 어떤 상황에서 사용되나요? 그리고 그 방법은 무엇인가요?**

혼잡 제어는 네트워크 상 데이터의 양이 라우터가 처리할 수 있는 양을 초과해 처리하지 못하게 되어 데이터가 손실되고, 이 때문에 재전송이 계속 발생하게 되면서 네트워크가 혼잡해지는 것을 방지하기 위해 필요합니다.

송신 측에서 전송 속도를 적절히 조절해서 예방할 수 있는데, 이를 혼잡 제어라고 합니다.

혼잡 제어의 다양한 기법들이 있는데, 제가 아는 한 가지 방법은 처음 패킷을 보냈을 때 문제가 없으면 윈도우 크기를 2배씩 증가시키며 전송하고, 실패하면 윈도우 크기를 1로 다시 줄이는 slow start 방법이 있습니다.

<br>

### 전송 계층의 전체 과정은?

- Application layer : sender application layer가 socket에 data를 씀.
- Transport layer : data를 segment에 감싼다. 그리고 network layer에 넘겨줌.
- 그러면 아랫단에서 어쨋든 receiving node로 전송이 됨. 이 때, sender의 send buffer에 data를 저장하고, receiver는 receive buffer에 data를 저장함.
- application에서 준비가 되면 이 buffer에 있는 것을 읽기 시작함.
- 따라서 flow control의 핵심은 이 receiver buffer가 넘치지 않게 하는 것임.
- 따라서 receiver는 RWND(Receive WiNDow) : receive buffer의 남은 공간을 홍보함

<br><br>

### HTTP통신, TCP통신 둘 중 필요한 경우는?

- HTTP통신은 소켓 연결 과정(3 way- Handshake)이 없으므로 간단한 정보들을 주고 받을 때 사용하면 좋습니다. 웹 페이지 처럼 단순한 데이터들로만 구성이 되어 있는 경우가 되겠습니다.
- TCP통신 역시 위와 같은 예시로 사용할 수 있지만, 이는 서버에 소켓 연결로써 계속 언제든 통신을 주고 받을 준비를 하기 때문에 여러 Client가 붙으면 그만큼 서버에 부담이 됩니다. 하지만 실시간 통신이 필요하다면 사용할 수 있겠습니다.

<br><br>

### DNS 란?

DNS란 '[www.google.com](http://www.google.com/)'같은 도메인 네임과 IP주소를 매칭해 사용자의 컴퓨터가 서버로 접근할 수 있도록 하는 서비스를 제공합니다.

<br>

#### **도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해주세요. (DNS가 어떻게 IP 주소를 가져오는지 설명해주세요.)**

Recursive Query를 통해 접근 : Local DNS 서버 -> Root DNS 서버 -> com DNS 서버(TLD 서버) -> [naver.com](http://naver.com) DNS 서버

1. 로컬 DNS서버에 해당 url이 등록되어있는지 확인
2. 캐싱이 안되어 있는 경우, 로컬 DNS 서버는 루트 DNS서버에 문의 후 최상위 도메인 .com이 등록된 네임 서버의 IP주소 전달
3. 로컬 DNS서버는 com DNS 서버에 해당 url을 문의함. com DNS 서버는 로컬 DNS서버에 [naver.com](http://naver.com) DNS 서버의 IP 주소 알려줌
4. 로컬 DNS 서버는 [naver.com](http://naver.com/) DNS 서버에 해당 url 문의함. 로컬 DNS는 IP 주소를 응답으로 받아 캐싱한다.
5. 로컬 DNS 서버는 캐싱한 후, 사용자에게 ip 주소를 응답으로 전달한다.

<br><br><br>

# **기타**

### IP 주소의 표기 방법은?

<br>

### 아직 IPv4를 사용할 수 있는 이유는?

<br>

### **공인 IP와 사설 IP의 차이에 대해 설명해주세요**

- 공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP주소 입니다.
- 사설 IP는 어떤 네트워크 안에서만 내부적으로 사용되는 고유한 주소입니다. 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.
- 사설 IP 주소만으로는 인터넷에 직접 연결할 수 없고, 라우터를 통해 1개의 공인 IP를 할당하고, 라우터에 연결된 개인 PC는 사설 IP를 각각 할당 받아 인터넷에 접속 할 수 있습니다.

<br>

### 사설 IP → 외부 인터넷 입장에서 주소 번호가 똑같은 사설 IP들을 어떻게 각각을 특정해 정확히 찾아들어가 우리에게 웹페이지를 띄울 수 있는 것일까?

NAT, Netwrok Address Translation 을 통해 공인 IP와 사설 IP를 변환해줍니다. 외부에서는 공인 IP 정보만 가지고 있고, 중간에 라우팅을 통해서 내부 사설 IP 주소로 변환해주는 것입니다.

<br>

### **127.0.0.1 과 localhost는 무엇을 의미하나요?**

만약 목적지 IP 주소를 127.0.0.1로 설정하게 되면 A의 네트워크 계층은 이 패킷을 외부로 전송하지 않고 자신이 송신한 패킷을 그대로 수신한 효과를 주게 됩니다.

예약된 주소로 할당할 수 없는 주소이며 자체 IP에서 할당 작동하여 인터넷이 연결되어있지 않아도 작동합니다.

<br>

### **주소창에 http://www.test.com 입력 후 엔터 눌렀을 때부터 페이지가 렌더링되는 과정에 대해 설명해주세요. (웹 동작 방식 이해)**

https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Network/주소창에 naver.com을 치면 일어나는 일.md

- 사용자가 브라우저에 URL([www.naver.com](notion://www.notion.so/www.naver.com))을 입력
- DNS 서버에 도메인 네임으로 서버의 진짜 주소를 찾음
  - local DNS → 루트 DNS 서버 → .com DNS 서버 → [test.com](http://test.com) DNS 서버 순서대로 [www.test.com](notion://www.notion.so/www.test.com)에 해당하는 IP주소 요청하고, 있다면 그 서버에서 바로 주소를 받음
- TCP 통신을 통해 소켓을 만들고 HTTP 프로토콜로 요청합니다.
- 클라이언트는 웹 서버로 HTTP 요청 메시지를 보내고, 웹 서버는 HTTP 응답 메시지를 보냅니다.
- 도착한 HTTP 응답 메세지는 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 파싱되어 출력됩니다.

<br>

### **프록시 서버란?**

클라이언트와 서버 중간에서 대리해주는 서버로 대개 보안과 요청/응답을 필터링하기 위해 사용합니다.

예를 들어 회사에서 무언가 다운 받을 때 바이러스를 검출한다던가, 초등학교에서 성인 컨텐츠를 차단하는 식입니다.

<br>

#### **프록시 서버가 필요한 이유**

프록시는 보안, 속도, ACL, Log/Audit, 접속 우회를 위해 사용됩니다.

- 보안은 프록시 서버가 중간에 경유하게 되면 IP를 숨기는 것이 가능하기 때문에 프록시 서버를 방화벽으로 사용하기도 하며 익명의 사용자가 서버에 접근하는 것을 막습니다.
- 속도 개선은 프록시는 요청 내용을 캐시하므로 동일 요청이 들어오면 서버에 따로 접속할 필요 없이 캐시 자원을 반환합니다. 따라서 전송 시간을 절약할 수 있고 외부 트래픽을 줄임으로써 네트워크 병목 현상도 방지할 수 있습니다.
- ACL : ACL은 프록시 서버에 접속할 수 있는 범위를 설정하는 옵션으로 사이트 접근에 대한 접근 정책을 정의할 수 있다.
- Log/Audit : 회사 내 직원의 인터넷 사용을 레포팅할 수 있습니다. 반대로 인트라넷의 사용을 레포팅할 수도 있습니다.
- 접속 우회 : 간혹 한국에서는 접속이 제한되는 사이트가 있는데, 이 경우 IP를 검사해 한국에서의 접속임을 감지하기 때문에 이런 경우 프록시 서버를 사용해 접속을 다른 나라로 우회할 수 있게 됩니다. 우회에 사용할 서버 주소와 포트를 구한 후에 다른 서버에서 접속한 것처럼 속여 접속 제한을 우회할 수 있습니다.

<br><br>

### **동기와 비동기의 차이는?**

- **Synchronous** : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.
- **Asynchronous** : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (Callback)

<br>

### Blocking과 Non-Blocking 차이는?

`호출된 함수`가 `호출한 함수`에게 제어권을 건네주는 유무의 차이

- **Blocking** : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.
- **Non-blocking** : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다. A는 B를 기다리면서도 다른 일을 진행할 수 있다.

<br><br><br>

# **References**

- https://hyonee.tistory.com/136
- https://mangkyu.tistory.com/88
- https://ko.myservername.com/top-60-networking-interview-questions
- https://ko.myservername.com/10-best-video-streaming-services-2021
- https://velog.io/@xoqja055/면접-준비를-해보자-네트워크
- https://velog.io/@yanghl98/CS-면접질문-대비-네트워크
- [프록시 서버](https://velog.io/@syoung125/개념공부-프록시proxy-서버란)
- https://minhamina.tistory.com/234
- https://mytutorials.tistory.com/51