## 인덱스, B트리, B+트리, 조인

## 목차

1. [인덱스란](#인덱스란)
    - [인덱스의 특징](#인덱스의-특징)
        - [인덱스 테이블](#인덱스-테이블)
        - [정렬](#정렬)
        - [인덱스 관리](#인덱스-관리)
    - [INDEX는 어떻게 동작하는가?](#index는-어떻게-동작하는가)
        - [B+Tree 인덱스 알고리즘](#btree-인덱스-알고리즘)
    - [INDEX 종류](#index-종류) 
    - [결합 인덱스(다중 컬럼 인덱스)란](#결합-인덱스다중-컬럼-인덱스란)
        - [결합 인덱스가 적용되는 경우와 적용되지 않는 경우](#결합-인덱스가-적용되는-경우와-적용되지-않는-경우)
        - [결합 인덱스 순서의 중요성](#결합-인덱스-순서의-중요성)
    - [INDEX 설계 시 고려할 점](#index-설계-시-고려할-점)
        - [인덱스 컬럼 기준](#인덱스-컬럼-기준)
    - [ORDER BY 와 GROUP BY에 대한 INDEX](#order-by-와-group-by에-대한-index)
    - [인덱스 조회시 주의 사항](#인덱스-조회시-주의-사항)
        - [범위 조건(LIKE, BETWEEN, <, >)과 INDEX](#범위-조건like-between--과-index)
        - [=, in과 INDEX](#-in과-index)
        - [컬럼값 가공금지](#컬럼값-가공금지)
        - [null 값의 경우](#null-값의-경우)
        - [OR 조건](#or-조건)
1. [B-트리](#b-트리)
    - [B-트리란?](#b-트리란)
    - [B-트리 모양의 특징(6가지)](#b-트리-모양의-특징6가지)
    - [B-트리 탐색 과정](#b-트리-탐색-과정)
    - [B-트리 삽입 과정](#b-트리-삽입-과정)
    - [B-트리 삭제 과정](#b트리-삭제-과정)
    - [B-트리 특징 정리](#b-트리-특징-정리)
1. [B+트리](#b트리)
    - [B+트리란?](#b트리란)
    - [B+트리 의의](#b트리-의의)
    - [B+트리 장단점](#b트리-장단점)
1. [B-트리와 B+트리 비교](#b-트리와-b트리-비교)
1. [조인](#조인)
    - [Join이란?](#join이란)
    - [Nested-Loop-Join(Join 동작 원리)](#nested-loop-joinjoin-동작-원리)
    - [Inner Join](#inner-join)
    - [Left Outer Join](#left-outer-join)
    - [Right Outer Join](#right-outer-join)
    - [Self Join](#self-join)
    - [Natural Join](#natural-join)
    - [Cross Join](#cross-join)
1. [예상질문](#예상질문)

## 인덱스란

- 인덱스는 `테이블의 조회 성능을 높여주는 자료구조`로 데이터의 위치를 빠르게 찾아주는 역할
- `인덱스는` MYI(MySQL Index)`파일에 저장`되며, 인덱스가 설정되지 않았다면 `Table Full Scan`이 일어나 성능이 저하되거나 치명적인 장애가 발생한다.
   
## 인덱스의 특징

### 인덱스 테이블

- 인덱스는 `하나의 테이블을 생성해 값을 저장해놓고 사용`한다.
- 그래서 `기존 테이블에 의존적인 새로운 테이블이 하나 생성된다`는 점에서 무분별한 인덱스 생성은 오히려 성능 저하를 초래할 수 있음

### 정렬

- 인덱스 테이블은 `이진트리 검색을 사용`하므로 `기본적으로 정렬되어 있음`
- 그래서 인덱스 테이블이 참조하는 테이블에서 삽입, 삭제, 수정이 자주 일어나게 되면
- 인덱스 테이블에서는 `데이터를 정렬하면서` 삽입, 삭제, 수정이 일어나기 때문에 전체적인 성능 저하 초래
  - 조회속도는 빨라지지만 `UPDATE`, `INSERT`, `DELETE`의 `속도는 저하`된다는 단점이 있다. 
  - `Table의 index 색인 정보를 갱신`하는 `추가적인 비용` 소요

### 인덱스 관리

- `INSERT`: 새로운 데이터에 대한 인덱스를 추가
- `DELETE`: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업(표시) 진행
- `UPDATE`: '기존의 인덱스를 사용하지 않음' 처리 후, 갱신된 데이터에 대한 인덱스를 추가

> UPDATE, DELETE가 빈번한 컬럼에 대해 인덱스를 적용하게 되면     
> 실제 데이터 갯수에 비해 인덱스의 크기가 비대해져서 성능이 저하되는 역효과 발생

## INDEX는 어떻게 동작하는가?

![스크린샷 2022-10-13 오전 1 00 00](https://user-images.githubusercontent.com/75410527/195391949-d6dbb713-6bc9-4ac4-a46e-7ff8dd59331d.png)

- SCOUNTER TABLE 생성 시 AIRPORT 컬럼에 대한 인덱스를 주면 AIRPORT 컬럼에 대한 인덱스 테이블이 생성된다.
- 그리고 나중에 SCOUNTER 테이블에 AIRPORT 컬럼에 대한 WHERE문이 포함된 쿼리가 나갈 때,
- AIRPORT 인덱스 테이블에 저장된 key-value 값을 참조해서 SCOUNTER TABLE 테이블에서 결과 값을 반환해온다.

### 동작순서

1. Index Table에서 where에 포함된 값을 찾음
1. 해당 컬럼의 인덱스 테이블에 저장된 key-value 값을 참조
1. 가져온 인덱스 테이블에 저장된 key-value 값으로 원본 테이블에서 값을 조회해옴

#### 그리고 DBMS는 INDEX를 다양한 알고리즘으로 관리하고 있는데, 일반적으로 사용하는 알고리즘은 B+Tree 알고리즘

### B+Tree 인덱스 알고리즘

<img width="700" alt="스크린샷 2022-09-29 오후 10 10 42" src="https://user-images.githubusercontent.com/75410527/193040581-e6b57462-1eb9-4a30-8970-12a44aec33a8.png">

#### B+Tree 구성

> 루트 노드: 경로의 출발점 노드  
> 논리 노드: `리프 노드까지의 경로` 역할을 하는 노드  
> 리프 노드: `실제 데이터가 저장`되는 노드  

- B+Tree는 리프 노드에 이르기까지 자식 노드에 대한 포인터가 저장되어 있어 탐색 시 루트 노드에서 `한 개의 경로만 검색`하면 되기 때문에 검색에 있어 효율적
- 각 노드의 `자료는 정렬`되어 있습니다. 
- `모든 left node는 같은 레벨`에 있습니다.

## INDEX 종류

### 키에 따른 인덱스 분류

- 기본 인덱스(Primary Index): 기본키를 포함하는 인덱스(키의 순서가 레코드의 순서를 결정)
- 보조 인덱스(Secondary Index): 기본 인덱스 이외의 인덱스

### 파일 조직에 따른 인덱스 분류

- `Clustered Index`
  - 데이터 레코드의 물리적 순서가 그 파일에 대한 인덱스 엔트리 순서와 동일하게 유지되도록 구성된 인덱스 
  - Mysql의 경우 PK 설정시, 기본적으로 PK를 기준으로 Clustered Index 생성
  - `테이블당 한 개`를 만들 수 있다.
- `Unclustered Index`
  - 파일 인덱스 엔트리 순서가 데이터 레코드의 물리적 순서와 일치하지 않음. 
  - 파일 인덱스 엔트리의 리프 노드에는 해당 레코드의 주소값이(실제 값X) 들어가 있음
  - 물리적으로 데이터를 정렬하지 않는 대신 `위치정보를 인덱스로 구성`

## 결합 인덱스(다중 컬럼 인덱스)란

- 다중 컬럼 인덱스는 두개 이상의 필드를 조합해서 생성한 INDEX
- 주 용도는 SQL에서 WHERE절의 조건 `컬럼이 2개 이상 AND로 연결되어 함께 사용되는 경우`에 많이 사용
- 다중 컬럼 인덱스는 단일 컬럼 인덱스 보다 `INSERT/UPDATE/DELETE 연산을 수행함에 있어 오버헤드가 높기 때문에` 신중해야한다.

#### Table1(단일 인덱스)

```sql
CREATE TABLE table1(
    uid INT(11) NOT NULL auto_increment,
    id VARCHAR(20) NOT NULL,
    name VARCHAR(50) NOT NULL,
    address VARCHAR(100) NOT NULL,
    PRIMARY KEY('uid'),
    key idx_name(name),
    key idx_address(address)
)
```

#### Table2(다중 컬럼 인덱스)

```sql
CREATE TABLE table2(
    uid INT(11) NOT NULL auto_increment,
    id VARCHAR(20) NOT NULL,
    name VARCHAR(50) NOT NULL,
    address VARCHAR(100) NOT NULL,
    PRIMARY KEY('uid'),
    key idx_name(name, address)    
)
```

#### QUREY문

```sql
SELECT * FROM table1 WHERE name='홍길동' AND address='경기도';
```

#### Table1

- table1의 경우에 각각 컬럼(name),(address)에 INDEX가 걸려있기 때문에 
- MySQL은 name컬럼과 address컬럼을 보고 `둘 중에 어떤 컬럼의 수가 더 빠르게 검색되는지 판단 후` 
- 빠른쪽을 먼저 검색하고 그 다음 다른 컬럼을 검색하게 된다.

#### Table2

- table2의 경우 `바로 원하는 값을 찾는데` 그 이유는 `INDEX를 저장할 때 name과 address를 같이 저장`하기 때문이다. 
- 즉, name과 address의 `값을 같이 색인`하고 검색에서도 '홍길동경기도'로 검색을 시도하게 된다.
- 이렇게 사용할 경우 table1보다 table2의 경우가 더 빠른 검색을 할 수 있다.

### 결합 인덱스가 적용되는 경우와 적용되지 않는 경우

- 다중 컬럼 인덱스를 사용할 때는 INDEX로 설정해준 `제일 왼쪽컬럼`이 `WHERE절에 사용되어야` 한다.
  - 인덱스는 `B+Tree 자료구조 탐색`을 하기 때문

#### 결합 인덱스가 적용되는 경우

- 조회 조건이 `B+Tree 자료구조 탐색`에 위배되지 않는다면 인덱스와 완전히 동일한 조회 조건이 아니어도 결합 인덱스가 적용된다
- 결합 인덱스의 `제일 왼쪽 컬럼`인 `name`이 사용되었으므로 인덱스가 적용된다

```sql
key idx_name(name, address)    

SELECT * FROM table2 WHERE name='홍길동';
```

```sql
key idx_name(name, address, age)   

WHERE name = ? AND address = ?;
```

#### 결합 인덱스가 적용되지 않는 경우

- 조회 조건이 `B+Tree 자료구조 탐색`에 위배되는 경우 결합 인덱스가 적용되지 않음
  - 제일 왼쪽 컬럼부터 `연속된 조회 조건이 아닌 경우`  
- 결합 인덱스의 `제일 왼쪽 컬럼이 조회 조건에 사용되지 않았으므로` 인덱스가 적용되지 않음

```sql
key idx_name(name, address)    

SELECT * FROM table2 WHERE address='경기도';
```

- age 컬럼은 인덱스가 적용되지 않는다.

```sql
key idx_name(name, address, age)   

WHERE name = ? AND age = ?; 
```

### 결합 인덱스 순서의 중요성

- `카디널리티가 높은 순서대로` `내림차순으로 적용`하는 게 성능상 제일 좋음 
  - 결합 인덱스에서는 첫 번째 조건에서 최대한 많은 데이터를 걸러내서 두 번째 조건을 검사하도록 해야 합니다.
  
```sql
# 시간 정보는 카디널리티가 높으므로 그나마 나음
key idx_name(created_at, payment_state)   

# 1댑스 인덱스에서 데이터를 거의 걸러내지 못함 
key idx_name(payment_state, created_at)
```

## INDEX 설계 시 고려할 점

- 무조건 많이 설정하지 않는다. (한 테이블당 3~5개가 적당, 목적에 따라 상이)
  - 왜냐면 Table의 `index 색인 정보를 갱신하는 추가적인 비용이 많이 소모`됨
  - 또한, index 데이터 크기가 커지므로(`인덱스도 엄연히 테이블처럼 크기를 차지`) 불필요한 인덱스로 크기가 커지는 건 바람직하지 않음. 

### 인덱스 컬럼 기준

- 조회시 자주 사용하는 컬럼
- UPDATE가 빈번하지 않은 컬럼
- JOIN 시 자주 사용하는 컬럼
- 카디널리티가 높은 컬럼 (주민등록번호 vs 성별, 한 컬럼이 가지고 있는 중복의 정도)


## ORDER BY 와 GROUP BY에 대한 INDEX

INDEX는 ORDER BY와 GROUP BY에도 영향을 끼치는데 다음과 같은 경우에는 INDEX가 적용되지 않습니다.

- WHERE 컬럼1='값' ORDER BY 인덱스 컬럼 : 연속하지 않은 컬럼에 대해 ORDER BY를 실행한 경우
  - ORDER BY도 똑같이 `B+Tree 자료구조 탐색` 조건에 위배되지 않아야 인덱스가 걸림
- ORDER BY 인덱스컬럼1 DESC, 인덱스컬럼2 ASC : `DESC와 ASC를 혼합해서 사용`한 경우
  - 정렬되는 각 컬럼의 오름차순 및 내림차순 옵션이 `인덱스와 같거나 정반대인 경우`에만 사용가능 
- GROUP BY 컬럼1 ORDER BY 컬럼2 : GROUP BY와 ORDER BY의 컬럼이 다른 경우
- ORDER BY ABS(컬럼) : ORDER BY 절에 `다른 표현`을 사용한 경우

## 인덱스 조회시 주의 사항

### 범위 조건(LIKE, BETWEEN, <, >)과 INDEX

between, like, <, > 등 `범위 조건은 해당 컬럼은 인덱스를 타지만`, `그 뒤 인덱스 컬럼들은 인덱스가 사용되지 않습니다.`

- `group_no, from_date, is_bonus`으로 인덱스가 잡혀있다고 가정하겠습니다.
- 조회 쿼리를 `where group_no=XX and is_bonus=YY and from_date > ZZ` 등으로 잡으면 is_bonus는 인덱스가 사용되지 않습니다.
  - `중간에 from_date에서 범위 탐색`을 함으로써 인덱스가 적용되지 않음

### =, in과 INDEX

- `=`, `in`은 다음 컬럼도 인덱스를 사용합니다.
  - 왜냐면 `in`은 결국 `=`를 `여러번 실행`시킨 것이기 때문입니다.
  - 단, in은 `인자값으로 상수가 포함되면 문제 없지만`, 서브쿼리를 넣게되면 성능상 이슈가 발생합니다. 

### 컬럼값 가공금지

- 인덱스는 가공된 데이터를 저장하고 있지 않습니다.
- 인덱스로 사용된 `컬럼값 그대로 사용해야만 인덱스가 사용`됩니다.
  - `where salary * 10 > 150000;`는 인덱스를 사용하지 않습니다.
  - 하지만, `where salary > 150000 / 10;`는 인덱스를 사용합니다.
  - `ABS(컬럼)` 이런것도 인덱스가 

### null 값의 경우

- null 값의 경우 `is null 조건`으로 `인덱스 레인지 스캔 가능`

### OR 조건

- `AND` 연산자는 각 조건들이 읽어와야할 ROW 수를 줄이는 역할을 합니다.
- 하지만 `OR` 연산자는 비교해야할 ROW가 더 늘어나기 때문에 풀 테이블 스캔이 발생할 확률이 높습니다.

## B-트리

### B-트리란?

![스크린샷 2022-10-12 오후 10 20 14](https://user-images.githubusercontent.com/75410527/195353606-e4a40d54-012e-4f57-ad8a-30d56f191d30.png)

> B-트리는 트리 자료구조의 일종으로 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조.   
> 이진 트리와는 다르게 하나의 노드에 많은 정보를 가질 수 있습니다.       
> 이렇게 하나의 노드에 여러 정보를 담게 되면서 `차수`라는 개념이 등장합니다.       

- 허용하는 자식 노드가 최대 M개라면 M차 B-Tree라고 부릅니다.
- 이렇게 하나의 노드에 여러 자료를 배치하게 되면서 이진 트리보다 훨씬 많은 데이터를 더 효율적으로 저장소에 담을 수 있게 되었습니다.

```
하드디스크나 SSD와 같은 외부 기억장치는 `블럭단위로 파일을 입출력`합니다. 
이때 발생하는 입출력의 비용은 파일의 크기와는 상관 없이 동일합니다. 
입출력에 있어서는 1KB짜리 블럭에 1byte짜리 알파벳 하나가 들어가 있어도 1KB가 꽉 차있는 블럭과 차이가 없습니다.
이 떄 하나의 블럭에 여러 데이터들을 동시에 저장할 수 있다면 블럭을 보다 효율적으로 사용할 수 있을 것입니다.
그래서 많은 데이터베이스들은 B-Tree를 애용합니다.
```

- 또한 B-Tree는 균형이진트리의 연속이므로 균형도 유지합니다. 
- 따라서 아무리 최악의 경우라도 O(logN)의 검색 성능을 보여줍니다.

### B-트리 모양의 특징(6가지)

#### 1. 노드에는 2개 이상의 데이터(key)가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다.

![스크린샷 2022-10-12 오후 9 48 46](https://user-images.githubusercontent.com/75410527/195346671-6510c22c-c437-4b00-9a5e-a9f93e8e7869.png)

> 한 노드에 2개, 3개의 데이터가 들어가 있을 수 있으며, 항상 정렬된 상태로 저장된다.

#### 2. 내부 노드는 M/2 ~ M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B-트리를 M차 B-트리라고 한다.

> 위 그림은 3차 B-트리를 나타낸다. 즉, 3차 B-트리의 리프 노드를 제외한 내부 노드는 1개~3개의 자식을 가질 수 있다.

#### 3. 특정 노드의 데이터(key)가 K개라면, 자식 노드의 개수는 K+1개여야 한다.

![스크린샷 2022-10-12 오후 9 49 36](https://user-images.githubusercontent.com/75410527/195346809-067f6d84-13d6-424e-8c0d-f378f6cc4f2b.png)

> 특정 노드의 데이터가 2개면 자식 노드는 3개이고, 특정 노드의 데이터가 1개면 자식 노드는 2개여야 한다.    
> 그래서 왼쪽 그림은 부모 노드 개수(2개), 자식 노드 개수(3개)로 조건을 만족하지만,    
> 오른쪽 그림은 부모 노드 개수(2개), 자식 노드 개수(4개)로 B 트리의 조건을 만족하지 못한다.    

올바른 B-트리 예시

![스크린샷 2022-10-12 오후 9 56 38](https://user-images.githubusercontent.com/75410527/195348464-e9e829e8-72bf-40ab-adc6-23b46d14b28b.png)

#### 4. 특정 노드의 왼쪽 서브 트리는 특정 노드의 key 보다 작은 값들로, 오른쪽 서브 트리는 큰 값들로 구성된다.

![스크린샷 2022-10-12 오후 10 00 10](https://user-images.githubusercontent.com/75410527/195349231-32a5d6b1-fc1c-4a80-9876-efdc92c2232a.png)

> 노드 내에서 key가 a1, a2, a3... 등으로 존재한다면,     
> a1 왼쪽 서브 트리는 a1보다 작아야 하고,     
> a1과 a2 사이의 서브 트리는 a1보다는 크면서 a2보다는 작아야 한다.    
> B-트리는 노드 내에 key 값이 2개 이상 들어갈 수 있기 때문에 자식 노드를 가리키는 포인터의 개수는 key의 개수보다 1개 더 많다.    

#### 5. 노드 내에 데이터는 floor(M/2)-1개부터 최대 M-1개까지 포함될 수 있다

![스크린샷 2022-10-12 오후 10 00 10](https://user-images.githubusercontent.com/75410527/195349231-32a5d6b1-fc1c-4a80-9876-efdc92c2232a.png)

> 3차 B-트리는 노드 내에 0~2개의 데이터를 가질 수 있다.

#### 6. 모든 리프 노드들이 같은 레벨에 존재한다.

> 모든 리프 노드들은 같은 레벨에 존재해야 한다. 즉, 루트 노드에서 모든 리프 노드로 가는 경로의 길이가 같다. 

![스크린샷 2022-10-12 오후 10 05 52](https://user-images.githubusercontent.com/75410527/195350546-c33f945f-6b93-4424-b3b8-98eb73ed0a91.png)

### B-트리 탐색 과정

> B-트리는 루트 노드에서 탐색을 시작하여 하향식으로 탐색을 진행한다. 
> 찾고자 하는 값이 K라면 다음과 같은 과정을 거친다.

1. 루트 노드에서 탐색을 시작한다.
2. K를 찾았다면 탐색을 종료한다.
3. K와 노드의 key값을 비교해 알맞은 자식 노드로 내려간다.
4. 해당 과정을 리프 노드에 도달할 때까지 반복한다. 
5. 리프 노드에서도 K를 찾지 못한다면 트리에 값이 존재하지 않는 것 

- 참고: [[자료구조] B-트리(B- Tree)란? B트리 그림으로 쉽게 이해하기, B트리 탐색, 삽입, 삭제 과정](https://code-lab1.tistory.com/217)

### B-트리 삽입 과정

> B-트리에 데이터를 삽입하는 과정은 탐색과는 다르게 `상향식`으로 진행된다. 
> B-트리에서의 데이터 삽입은 `항상 리프 노드에서 시작`된다.     

1. 해당원소가 들어 가야할 리프노드를 찾는다. 
2. 노드에 빈 자리가 있다면 새로운 원소를 삽입한다.
3. 노드에 빈 자리가 없다면 노드를 2 개로 분할한다.
4. 기존 노드의 원소와 새로운 원소 중에 중간 값을 분할된 부모 노드의 값으로 한다. 
5. 중간 값보다 작은 값은 왼쪽 노드로 큰 값은 오른쪽 노드에 넣는다
6. 중간 값을 부모 노드로 넣을 때, 부모 노드에 자리가 없으면 부모 노드도 위의 규칙에 의해 분할한다

> 적절한 상태?     
> 적절한 상태란, 해당 노드의 데이터 개수가 허용 범위 안에 있는 것을 의미.     
> 반대로 부적절한 상태란 해당 노드의 데이터 개수가 허용 범위를 벗어나 너무 많은 상태를 뜻한다.    

- 참고: [[자료구조] B-트리(B- Tree)란? B트리 그림으로 쉽게 이해하기, B트리 탐색, 삽입, 삭제 과정](https://code-lab1.tistory.com/217)

### B트리 삭제 과정

삭제 과정중에서도 아래와 같은 조건을 만족해야 하며, 조건이 위반되면 트리를 재구조화 한다.

1. 내부 노드(루트가 아닌 노드)는 M/2 ~ M개의 자식 노드를 가질 수 있다.
2. 각 노드는 floor(M/2)-1 ~ M-1 개의 데이터(key)를 가질 수 있다.
3. 노드의 key가 K개 라면 자식 노드의 개수는 K+1개여야 한다.

- 참고: [[자료구조] B-트리(B- Tree)란? B트리 그림으로 쉽게 이해하기, B트리 탐색, 삽입, 삭제 과정](https://code-lab1.tistory.com/217)

### B-트리 특징 정리

- 각 노드의 자료는 `정렬`되어 있다
- 노드 내 `KEY 값은 유일`하다. (자료는 중복되지 않음)
- `모든 리프 노드는 같은 레벨`에 있다.
- 리프 노드, 브랜치 노드(중간 레벨의 노드)에 모두 데이터를 저장한다.

## B+트리

![스크린샷 2022-10-13 오전 12 52 55](https://user-images.githubusercontent.com/75410527/195390368-325becf8-0f5c-411b-a471-1c8bcd8edc8b.png)

### B+트리란?
  
> B-트리의 특징을 가지고 있지만, 모든 키 값들이 리프 노드에 정렬되어있는 트리 구조    
> 리프 노드를 순차적으로 연결하는 포인터 집합을 가지고 있는 자료 구조(선형 검색 가능)

- Index node들과 Data node(레코드)로 구성이 되어있다.
  - `Index node`: leaf node를 제외한 나머지 node. 인덱스 노드의 value에는 `다음 노드를 가리킬 수 있는 포인터 주소가 존재`
  - `Data node`: leaf node. 오직 리프노드에만 key와 data를 저장하고, 리프 노드끼리 연결 리스트로 연결. 데이터 노드의 value에는 `데이터가 존재`

### B+트리 의의

> B-트리는 탐색을 위해서 `노드를 찾아서 이동해야 한다는 단점`을 가지고 있습니다.   
> 이러한 단점을 해소하고자 B+트리는 같은 레벨의 모든 키값들이 정렬되어 있고, 같은 레벨의 Leaf node는 연결리스트 형태로 이어져 있습니다.

- 그래서 풀 스캔이 필요하다면 leaf node에 모든 자료들이 존재하고, 그 자료들이 연결리스트로 연결되어 있으므로 탐색에 있어서 매우 유리합니다.
- 오늘날 DB에서 제일 중요한 건 `검색속도`이기 때문에 대부분의 DB 시스템은 B+Tree 구조를 채택하고 있습니다.(ex. Mysql InnoDB)

![스크린샷 2022-10-13 오전 12 47 20](https://user-images.githubusercontent.com/75410527/195389138-595fc49e-48c7-4406-b578-51f823f0c9ab.png)

### B+트리 장단점

#### 장점

1. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key를 수용할 수 있다.
    - 하나의 노드에 더 많은 key를 담을 수 있기 때문에 `트리의 높이는 더 낮아진다.` 
    - B+트리의 높이는 B-트리 보다 낮게 구성되므로 검색시간과 디스크에 접근하는 횟수가 줄어든다
2. 풀 스캔 시, B+트리는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-트리에 비해 빠르다.
    - B-트리의 경우에는 모든 노드를 확인해야 한다.

#### 단점

- B-트리의 경우 best case에는 루트에서 끝날수 있지만, B+트리의 경우 `무조건 leaf노드까지` 가야한다.

## B-트리와 B+트리 비교

- 아래 표에서 말하는 데이터는 자료구조 상 value에 해당 (실제 DB 데이터가 X)

| 구분                  | B-트리                                                                                                                            | B+트리                                   |
|-----------------------|-----------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|
| 데이터 저장           | 리프 노드, 브랜치 노드 모두 데이터 저장 가능                                                                                      | 오직 리프 노드에만 데이터 저장 가능       |
| 트리의 높이           | 높음                                                                                                                              | 낮음(한 노드 당 key를 많이 담을 수 있음)  |
| 풀 스캔 시, 검색 속도 | 모든 노드 탐색                                                                                                                    | 리프 노드에서 선형 탐색                   |
| 키 중복               | 없음                                                                                                                              | 있음(리프 노드에 모든 데이터가 있기 때문) |
| 검색                  | 자주 access 되는 노드를 루트 노드 가까이 배치할 수 있고, 루트 노드에서 가까울 경우, 브랜치 노드에도 데이터가 존재하기 때문에 빠름 | 리프 노드까지 가야 데이터 존재            |
| 링크드 리스트         | 없음                                                                                                                              | 리프 노드끼리  링크드 리스트로 연결       |

| 공통점                                                             | 차이점                                                                                                                                                                                                                |
|--------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. 모든 leaf의 depth가 같다                                        | 1. B-트리의 각 노드에서는 key 뿐만 아니라 data도 들어갈 수 있다. 여기서 data는 disk block으로의 포인터가 될 수 있다. B+트리는 각 node에서는 key만 들어가야 한다. 그러므로 B+트리에서는 data는 오직 leaf에만 존재한다. |
| 2. 각 node에는 k/2 ~ k 개의 item이 들어있어야 한다.                | 2. B+트리는 B-트리와는 달리 add, delete가 leaf에서만 이루어진다.                                                                                                                                                      |
| 3. 둘 다 기본적으로 트리 탐색(search)                                              | 3. B+트리는 leaf node 끼리 linked list로 연결되어 있다.                                                                                                                                                              |
| 4. add시 overflow가 발생하면 split 한다                            |                                                                                                                                                                                                                       |
| 5. delete 시 underflow가 발생하면 redistribution하거나 merge 한다. |                                                                                                                                                                                                                       |

## 조인

### Join이란?

> 관계형 데이터베이스에서 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법. 여러 개의 테이블을 하나인 것처럼 활용한다.

## Nested-Loop-Join(Join 동작 원리)

![4_nestedloop](https://user-images.githubusercontent.com/75410527/192997653-7c100344-ada1-49bc-8316-13fbbfcecfd2.png)

#### Table A: Driving Table 혹은 Outer Table이라고 함
#### Table B: Driven Table 혹은 Inner Table이라고 함

```sql
# 등가조인[Equi Join]
# SELECT * FROM 테이블1, 테이블2
#	 WHERE 테이블명1.컬럼명1=테이블명2.컬럼명2;

SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
;
```

1. Table A에서 row를 하나씩 반복해가며 스캔한다.
1. Driving Table의 `row 하나 마다` 반대편 `Driven Table의 레코드를 하나씩 스캔`해서 Join 조건에 맞으면 데이터를 찾아서 가져온다.
    - 선행 테이블에서 row를 가져온 후 `조인 조건절(등가조인이므로 WHERE절)을 검사`해서 동일한 조건을 가진 레코드면 후행 테이블에서 가져옴.
1. 1~2 과정을 Driving Table의 `모든 row에 대해 반복`

## Nested Loop의 실행시간

- `Table A의 Row 개수` * `Table B의 Row 개수` = Nested Loop의 실행 시간
- R(A) * R(B) = 실행시간 인데, R(A) * R(B) == R(B) * R(A) 
- 여기서 재밌는 사실을 알 수 있습니다.
- `Driving Table이 무엇이 되었든` 조회결과는 R(A) * R(B), R(B) * R(A)이므로 `동일함`
- 그런데 우리는 `Driving Table은 작은걸 선택해야 성능이 좋아진다`는 이야기를 많이 들었습니다.
- 이 이야기에는 1개지 대전제가 있습니다.

#### 바로, "Driven Table(Table B)의 조인 키는 인덱스가 걸려 있어야 한다" 임

![4_nestedloop2](https://user-images.githubusercontent.com/75410527/192999660-b2b92bec-15b0-4c95-9e1d-9ef1b98a4d75.png)

- 일반적으로 조인은 `FK`를 통해 이루어지므로 위 대전제를 신경쓰지 않고 수행할때가 많음.
- 반대로 Fk를 비롯한 `인덱스가 전혀 없는 컬럼`을 통해 조인을 실행하면 Driving Table이 어떤것이 되었든 실행시간은 비효율적으로 나타납니다.
- 꼭 숙지해야할 내용은 이 한줄인것 같습니다.

#### Row가 적은 Driving Table + Driven Table의 조인키에는 인덱스가 걸려있어야 GOOD

### Inner Join

![Index_B-Tree_B+Tree_Join4](https://user-images.githubusercontent.com/75410527/195395133-9fc8f60a-963b-432e-aaba-4de20117e138.png)

> 기준테이블과 연결한 테이블의 중복된 값을 보여주는 JOIN

- WHERE절에서 사용하던 JOIN조건을 FROM절에서 사용
- 등가조인의 FROM절에서 두 테이블명을 연결할 때, 대신 INNER JOIN사용
- WHERE절 대신에 USING조건절이나 ON 조건절을 필수적으로 사용

### Left Outer Join

![Index_B-Tree_B+Tree_Join5](https://user-images.githubusercontent.com/75410527/195395238-8e3b9ab9-6f4f-48b8-9b74-1fe3d47e612b.png)

- `JOIN문의 왼쪽에 있는 칼럼을 기준`으로 오른쪽 칼럼의 데이터를 데이터 존재여부와 관계없이 출력
  - 오른쪽 칼럼에 `데이터가 없는 경우 NULL`로 출력
  - 왼쪽 칼럼과 오른쪽 칼럼의 동일한 데이터는 데이터 값 표시
  - 왼쪽 칼럼과 오른쪽 칼럼의 동일하지 않은 데이터는 오른쪽 칼럼에 NULL로 표시


### Right Outer Join

![Index_B-Tree_B+Tree_Join6](https://user-images.githubusercontent.com/75410527/195395473-fc477a3d-2541-4ce4-ae16-ce6b7d5075b2.png)

- `JOIN문의 오른쪽에 있는 칼럼을 기준`으로 왼쪽 칼럼의 데이터를 데이터 존재여부와 관계없이 출력
  - 왼쪽 칼럼에 데이터가 없는 경우 NULL로 출력
  - 오른쪽 칼럼과 왼쪽 칼럼의 동일한 데이터는 데이터 값 표시
  - 오른쪽 칼럼과 왼쪽 칼럼의 동일하지 않은 데이터는 왼쪽 칼럼에 NULL로 표시

### Self Join

![Index_B-Tree_B+Tree_Join8](https://user-images.githubusercontent.com/75410527/195396226-28d83040-4425-471b-9ea9-bed397c04018.png)

> 한 테이블 내 데이터를 활용하여 자체적으로 조인하는 방법

- 하나의 테이블에서 두 개의 컬럼이 연관 관계를 가지고 있는 경우 사용
  - ex. 상관 사원번호 => 부하 사원번호 
- 테이블과 컬럼명이 모두 동일하므로 식별을 위해 `반드시 별칭 사용`

```sql
SELECT 출력할 컬럼명1, 컬럼명2, ...
FROM 테이블명1 별칭1, 테이블명1 별칭2
WHERE 별칭1.컬럼명2=별칭2.컬럼명2
;
```

### Natural Join

```sql
SELECT 출력할 칼럼명1, 칼럼명2,..
	FROM 테이블명1 NATURAL JOIN 테이블명2;
```

- `두 테이블 간 동일한 이름을 갖는 모든 칼럼`에 대해 EQUI JOIN을 수행하는 방법
- USING 조건절, ON조건절, WHERE절에서의 JOIN조건을 함께 정의 불가
- NATURAL JOIN에 사용된 칼럼들은 `같은 데이터 유형`이어야 함
- NATURAL JOIN은 Alias(별칭)이나 테이블명과 같은 접두사(ex> EMP.DEPTNO)를 붙일 수 없음

> EQUI JOIN?    
> 테이블간의 공통 컬럼을 활용하여 각 테이블의 특정 컬럼에 일치한 데이터를 기준으로 연결하는 방법.   
> 등가조인(Equi Join) == 내부조인(Inner Join) == 단순조인(Simple Join). 


### Cross Join

![Index_B-Tree_B+Tree_Join7](https://user-images.githubusercontent.com/75410527/195396907-0bb39b24-db58-4ac4-96b1-bd25711b10e8.png)

> 조인되는 컬럼의 각각의 행들이 모두 매칭되어 출력되는 방법

- `카티션 곱`이라고도 한다.
- FROM을 이용한 테이블 연결과 동일한 결과
- 결과 값의 개수는 A테이블의 데이터 X B테이블의 데이터가 된다.
- 적절한 JOIN 조건이 없을 때 사용한다.

## 예상질문

- DB 인덱스에 대해서 설명해주세요(DB 인덱스는 무엇인가요?)
- 인덱스를 구현하는 방식에서 B+트리를 사용하는 방식과 해시를 사용하는 방식의 차이는 무엇일까요?
- 테이블에 설정될 수 있는 인덱스 형태들에는 어떤 것들이 있나요?
- Join 내부 동작 방식에 대해 알고 있나요?
- inner join vs outer join 차이는? 

## References

- [[MySQL] 인덱스(INDEX) 정리(효과적인 INDEX 설계)](https://spiderwebcoding.tistory.com/6)
- [[DataBase] DB 성능을 위한 Index](https://brunch.co.kr/@skeks463/25)
- [[자료구조] 간단히 알아보는 B-Tree, B+Tree, B*Tree](https://ssocoit.tistory.com/217#2._B*Tree)
- [GROUP BY, ORDER BY 인덱스 튜닝](https://lannstark.tistory.com/40)
- [[mysql] 인덱스 정리 및 팁](https://jojoldu.tistory.com/243)
- [[자료구조] B-트리(B- Tree)란? B트리 그림으로 쉽게 이해하기, B트리 탐색, 삽입, 삭제 과정](https://code-lab1.tistory.com/217)
- [[자료구조] 간단히 알아보는 B-Tree, B+Tree, B*Tree](https://ssocoit.tistory.com/217#1._B-Tree)
- [탐색자료구조(Binary Tree, B-Tree, B+ Tree, B* Tree, Bitmap Index)](http://ko.infomngproeng.wikidok.net/wp-d/60a1e50990b350fb11df6fa4/View#wk_cTitle7950)
- [인덱스, B-Tree, B+Tree, Join](https://github.com/workhardslave/cs-study/blob/main/Database/Index_B-Tree_B%2BTree_Join.md)
- [[개미의 걸음 SQLD 2과목] JOIN(외부조인, 내부조인, 등가조인 , 비등가조인 , 셀프조인, 네츄럴조인, 크로스 조인)](https://2030bigdata.tistory.com/222)
- [* JOIN 원리](https://kshmc.tistory.com/entry/JOIN-%EC%9B%90%EB%A6%AC)
- [패스트캠퍼스 SQL튜닝캠프 4일차 - 조인의 기본 원리와 활용](https://jojoldu.tistory.com/173)
