## Database 예상 질문

## 목차

1. [관계형 데이터베이스(RDB) 관련](#관계형-데이터베이스rdb-관련)
1. [트랜잭션 관련](#트랜잭션-관련)
1. [NoSQL 관련](#nosql-관련)
1. [인덱스 관련](#인덱스-관련)
1. [보안 관련](#보안-관련)

## 관계형 데이터베이스(RDB) 관련

<details>
<summary>Q.기본키(Primary Key)가 뭔지 설명해주세요</summary>

candidate key 중 선택한 main key로써, 각 row를 unique하게 구분하는 column(또는 column의 집합)을 말합니다. 그래서 기본키는 Null 값을 가질 수 없고, 중복된 값을 가질 수 없습니다. 기본키는 table당 1개만 지정해야합니다.
</details>

<details>
<summary>Q.기본키(Primary Key)가 되기 위해 필요한 조건에 대해 말씀해주세요</summary>

유일성, 최소성을 만족해야 하며 기본키가 되는 컬럼은 NULL이 되면 안 됩니다.
1. 유일성은 테이블 내 하나의 튜플을 유일하게 식별할 수 있는 속성을 의미합니다.
2. 최소성은 유일성을 만족하는 속성의 집합 중 속성(원소)가 하나만 사라져도 튜플을 유일하게 식별할 수 없음을 의미합니다.
</details>

<details>
<summary>Q.후보키, 기본키, 대체키, 외래키, 슈퍼키에 대해 설명해주세요</summary>

1. 후보키: 유일성, 최소성을 만족하는 속성의 집합입니다.
2. 기본키: 후보키 중 테이블 내 튜플을 식별할 수 있도록 선택된 키 입니다.
3. 대체키: 기본키를 제외한 나머지 후보키를 의미합니다.
4. 외래키: 참조하는 테이블의 기본키로, 각 테이블끼리 관계를 맺어줄 때 사용합니다.
5. 슈퍼키: 유일성만 만족하는 속성의 집합으로 최소성은 만족하지 않습니다.
</details>

<details>
<summary>Q.관계형 데이터베이스의 N:M 관계에 대해서 설명해 주세요.</summary>

관계형 데이터베이스에서 양쪽 entity 모두가 서로에게 1:N 관계를 갖는 구조를 말합니다. 그래서 실제로 구현할 때는 양쪽 테이블의 N:M 관계를 나타내는 중간 테이블을 정의하여 N:M 관계를 나타냅니다.
- 예시: 학생-수강과목 테이블의 관계. 한 명의 학생은 여러 개의 수강과목을 들을 수 있고, 하나의 수강과목은 여러 명의 학생이 선택할 수 있다. 그래서 학생-수강과목 관계를 나타내는 추가 테이블을 정의함으로써 N:M 관계를 나타낸다. (그냥 이 예시 기억하고 면접관한테 말하는 게 N:M 추상적으로 말하는 것보다 낫다고 생각)
  
</details>

<details>
<summary>Q.left outer join, inner join 차이를 설명해 주세요</summary>
  
Join이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것을 말합니다.
1. inner join(또는 join)은 두 테이블에 모두 있는 내용만 join되는 방식입니다. 
2. left outer join(또는 left join)은 왼쪽 table의 모든 행에 대해서 join을 진행합니다.
</details>

<details>
<summary>Q.데이터 정규화가 무엇인가요?</summary>

> 정규화 목표: 테이블 간에 중복된 데이터를 허용하지 않는 것    
> 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있음

관계형 데이터 베이스 설계에서 중복을 최소화하게 데이터를 구조화 하는 프로세스를 정규화라고 합니다.
- 1NF(Normal Form), 2NF, 3NF, BCNF, 4NF, 5NF, 6NF가 있으며 보통 3NF가 되면 '정규화 되었다'라고 합니다.
1. 제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것입니다.
2. 제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것입니다. (완전 함수 종속이라는 것은 기본키의 부분집합이 튜플의 결정자가 되어선 안된다는 것을 의미합니다)
3. 제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것입니다. (이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미합니다)
4. BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다. 
</details>

<details>
<summary>Q.무결성 제약사항 3가지에 대해 알고 있나요?</summary>

도메인 무결성, 개체(Entity) 무결성, 참조(References) 무결성이 있습니다.  
1. 도메인 무결성: 테이블에 주어진 속성으로 입력되는 값은 해당 도메인에 속하는 값이어야 합니다. (ex. 'M','W'만 입력하도록 했는데, 'X' 같은 데이터가 있는 경우)
2. 개체 무결성: 하나의 릴레이션에서는 중복된 튜플이 있어서는 안 된다는 뜻입니다.
3. 참조 무결성: 기본키와 참조 키의 간의 관계가 항상 유지되도록 보장하는 것을 말합니다. 참조 키에 존재하는 값은 참조 테이블에 실제로 존재하는 값이어야하고 두 값은 같아야 합니다.
</details>

## 트랜잭션 관련

<details>
<summary>Q.트랜잭션이 뭔지 설명해주세요</summary>

transaction는 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다. transaction은 하나 이상의 query를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야합니다. 
</details>

<details>
<summary>Q.트랜잭션의 특징에는 어떤게 있나요?</summary>

트랜잭션은 ACID라는 4가지 특징이 있습니다.
1. 원자성은 transaction에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 한다는 뜻입니다.
2. 일관성은 트랜잭션 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미합니다. 일관성 있다는 것은 트랜잭션의 결과로 데이터 제약조건에 위배되는 상태가 되지 않는 것을 말합니다.  
3. 고립성은 각 transaction 작업중에 다른 transaction이 끼어들지 못하도록 보장하는 것을 의미합니다. 그래서 동시에 수행되는 transaction이 동일한 data를 가지고 충돌하지 않도록 제어해줘야 합니다. 이를 동시성제어(concurrency control) 라고합니다.
4. 지속성은 성공적으로 수행된 transaction은 데이터베이스에 영원히 반영되어야 함을 의미합니다. transaction이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 합니다.
</details>

<details>
<summary>Q.트랜잭션 격리 수준(isolation level)에 대해서 알고 있나요? 알고 있다면 설명해주세요</summary>

트랜 잭션 격리수준은 멀티-트랜잭션 환경에서 발생할 수 있는 이상현상에 대해 고립 수준을 정해서 동시성을 제어하는 방법이며 4가지가 있습니다.
1. read-uncommitted: 다른 트랜잭션이 커밋하지 않은 데이터에 대해서도 조회할 수 있는 고립수준으로. dirty-read 문제가 발생합니다.
2. read-committed: 다른 트랜잭션이 커밋한 데이터에 대해서만 조회할 수 있는 고립수준으로 dirty-read 문제는 발생하지 않지만 unrepeatable-read 문제가 발생합니다.
3. repeatable-read: 현재 트랜잭션이 시작하기 이전에 커밋된 데이터에 대해서만 조회할 수 있는 고립수준으로 unrepeatable-read 문제는 발생하지 않지만 phantom-read 문제가 발생합니다.
4. serializable: 가장 높은 고립수준으로 3가지 이상현상이 모두 발생하지 않지만 동시성이 가장 떨어지는 고립수준입니다.
</details>

<details>
<summary>Q.트랜잭션에서 발생할 수 있는 데드락이 뭔지 설명해주세요</summary>

데이터베이스 deadlock(교착 상태)이란, 여러 `transaction`들이 각각 `자신의 데이터에 대하여 lock을 획득`한 상태에서 상대방 데이터에 대하여 접근하고자 대기를 할 때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말합니다. 즉, 두 transaction이 각각 lock을 설정하고, unlock을 하지 않은 상태에서 서로의 lock이 걸린 데이터에 접근하려고 할 때, 서로 대기를 계속하여 영원히 처리되지 않는 상황이 발생합니다.
</details>

<details>
<summary>Q.트랜잭션에서 발생할 수 있는 데드락을 해결하려면 어떻게 해야 하나요?</summary>

> timestamp를 사용하는 방식이란, 트랜잭션이 시작된 시간을 timestamp로 기록하고, 일찍 시작한 트랜잭션과, 늦게 시작한 트랜잭션 각 각이 데드락을 일으켰을 때 정책을 정해놔서 정책대로 처리하는 방식

> 정책1(Wait-die): `일찍 시작한 트랜잭션`은 대기 가능/늦게 시작한 트랜잭션은 rollback 시킴    
> 정책2(Wound-wait): `늦게 시작한 트랜잭션`은 대기 가능/일찍 시작한 트랜잭션은 rollback 시킴    
 

각 transaction이 실행되기 전에 사용될 모든 데이터를 미리 locking을 해주는 예방기법이 있고, 자원 할당시 timestamp를 사용하여 deadlock이 발생하지 않도록 회피하는 기법이 있습니다. 또한 deadlock이 발생하면 이를 감지하고 회복시키는 탐지/회복기법이 있습니다.
</details>

## NoSQL 관련

> NoSQL 써봤다는 얘기 안하셨으면 질문 안 들어오는 거 같아요. 그냥 RDB와의 차이점이랑 어떤 종류 있는지 아는 정도면 되지 않을까 싶습니다. 

<details>
<summary>Q.RDB - NoSQL를 비교 설명해 주세요.</summary>

1. 관계형 데이터베이스는 사전에 엄격하게 정의된 DB schema를 요구하는 table기반 데이터 구조를 갖습니다.
2. NoSQL은 table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원합니다.
3. RDB는 엄격한 schema로 인해 데이터 중복이 없기 때문에 데이터 update가 많을 때 유리합니다.
4. NoSQL의 경우 데이터 중복으로 인해 데이터 update 시 모든 컬렉션에서 수정이 필요하기 때문에 update가 적고 조회가 많을 때 유리합니다.

![스크린샷 2022-10-23 오후 3 57 50](https://user-images.githubusercontent.com/75410527/197378623-001c75aa-4a33-4b52-aa90-668c6418b2e3.png)
</details>

<details>
<summary>Q.NoSQL 종류에는 어떤 게 있나요?</summary> 
  
1. Key-value 형태로 데이터를 저장합니다. 조회 속도가 빨라 캐시 DB 용도나 세션 저장용으로 사용합니다.
2. Document 형태로 데이터를 저장합니다. 문서란 JSON, XML과 같은 형식을 말합니다. 서로 다른 필드를 가질 수 있어서 유연하게 대용량 데이터를 읽고 쓰는데 용이합니다.
3. Wide Column DB 형태로 저장합니다. Column이 모든 Row에 대해 항상 동일하지 않고, 여러 데이터 베이스 노드에 분산될 수 있는 대규모 데이터 셋이 필요할 때 사용하는 좋습니다. (ex. Log, 주식 거래 데이터나 기온 모니터링 데이터 등 시계열 데이터 저장)
4. Graph DB 형태로 저장합니다. 데이터 간의 관계가 탐색의 키일 경우(연관 데이터 추천 및 SNS 친구의 친구 질의)에 사용하면 적합한 DB입니다.
</details>

## 인덱스 관련

<details>
<summary>Q.인덱스가 왜 필요할까요?</summary>

인덱스가 필요한 이유는 조회 성능 향상을 위해서입니다. 인덱스를 사용하면 테이블에서 데이터 조회 시 full-scan이 아니라 range-scan을 할 수 있기 때문에 조회 성능 향상을 위해 사용합니다.
</details>

<details>
<summary>Q.인덱스 컬럼을 정해야 한다면 어떤 기준을 가지고 정할 건가요?</summary>

index는 where 절에서 자주 조회되고, 수정 빈도가 낮으며, 카디널리티는 높고, 선택도가 낮은 column을 선택해서 설정하는 것이 가장 좋습니다.

![스크린샷 2022-10-23 오후 4 14 18](https://user-images.githubusercontent.com/75410527/197379219-94eee6b7-4e63-4d3f-bb78-016fd7eda466.png)
</details>

<details>
<summary>Q.인덱스가 좋으면 모든 컬럼 마다 인덱스를 걸어놓으면 되지 않을까요?</summary>

그렇지 않습니다. index는 SELECT WHERE절에 대해서만 성능향상을 해줍니다. 이외에 데이터를 수정하게 되면 모든 index를 업데이트(+정렬)해야 하기 때문에 오히려 성능저하를 초래합니다. 또한 index를 생성할 때마다 저장공간도 차지하기 때문에 무분별하게 생성해서는 안됩니다.
</details>

<details>
<summary>Q.인덱스 내부 동작 방식에 대해 말씀해주세요</summary>

인덱스를 선언하면, 테이블로부터 파생되는 인덱스 테이블이 만들어집니다.
1. 인덱스 컬럼 기준으로 테이블이 key-value 형태로 정렬되어 저장됩니다.
2. 그리고 테이블에 인덱스 컬럼에 대한 조회 조건(ex. WHERE문)이 포함된 쿼리가 나갈 때
3. 인덱스 테이블에 저장된 key-value 값을 참조해서 테이블에 있는 결과 row 값을 반환해옵니다.
</details>

<details>
<summary>Q.인덱스 구현을 위한 자료구조로 hash-table과 b+tree가 있는데 왜 주로 b+tree를 사용할까요?</summary>

데이터베이스에서는 범위 조건으로 조회하는 경우도 많기 때문에 b+tree를 사용합니다.
1. 해시테이블의 경우 해시함수를 적용하게 되면 데이터간의 정렬 정보가 사라지게 됩니다. 그러므로 범위 조건 검색 시 시간이 더 오래걸립니다.
2. 반면에 b+tree의 경우 내부적으로 자료들이 정렬되어 있으므로 범위 조건 쿼리 시 더 빠르게 검색을 할 수 있습니다.
</details>

<details>
<summary>Q.테이블에 설정될 수 있는 인덱스 형태들은 어떤 형태들이 있나요?</summary>

클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Nonclustered Index)가 있습니다. 
1. 클러스터드 인덱스는 인덱스의 순서대로 실제 레코드가 위치하는 형태(지정한 컬럼에 대해 자동 정렬)로 테이블당 1개를 만들 수 있습니다.
2. 넌클러스터드 인덱스는 하나의 테이블에 대해 서로 다른 클러스터드 인덱스 사용이 불가능해 나온 개념으로, 물리적으로 데이터를 정렬하지 않는 대신 해당 테이블엔 인덱스(KEY)가 순차적으로 정렬되어 있고, 해당 KEY에 대한 VALUE로 PK(클러스티드 인덱스) 정보로 인덱스를 구성합니다. 

> 그래서 넌클러스터드 인덱스 탐색은 루트 노드에서부터 시작해서 Secondary Index를 통해 알아낸 Primary Key로 한번 인덱스 탐색이 이루어집니다.(MySQL InnoDB의 경우)
  
![스크린샷 2022-10-23 오후 4 38 19](https://user-images.githubusercontent.com/75410527/197380235-242bc8fe-6809-4769-8864-9318991dd940.png)

</details>

## 보안 관련

<details>
<summary>Q.SQL injection에 대해서 알고 있나요?</summary>

SQL injection은 악의적인 SQL문을 실행해서 DB를 비정상적으로 조작하는 공격방식입니다.
SQL injection을 방지할 수 있는 방법으로는 3가지가 있습니다.
1. 입력값 검증하기: 쿼리 관련 예약어나 단어가 들어오면 해당 요청 무시
2. 최소의 권한으로 DB 운영: DB 테이블 삭제 및 테이블 DROP 방지
3. 신뢰할 수 있는 네트워크에서만 접근할 수 있도록 하기
  
![c9f0d02cb20c312251aa14650d0cfdabb3a32e483b2526e78b1eb2c39f2b83a1da07371f351aef835a48bcd4a0c8235064d11747d19ecef994e2cf74c1415bc1ceca7c78a1b982aecc3df7aa83a6f6c3ffa162b96f028d1342b702404915da66](https://user-images.githubusercontent.com/75410527/197380573-106b48c3-4293-425c-89dd-4cfb8fa93d98.png)
</details>

## References

- [카디널리티 VS 선택도 (feat. NDV, Density)](https://velog.io/@jduck1024/%EC%B9%B4%EB%94%94%EB%84%90%EB%A6%AC%ED%8B%B0-VS-%EC%84%A0%ED%83%9D%EB%8F%84-feat.-NDV-Density#3-%EC%84%A0%ED%83%9D%EB%8F%84selectivity)
- [Mysql 인덱스 - 클러스티드 인덱스와 논클러스티드 인덱스 개념편](https://sihyung92.oopy.io/database/mysql-index#0164dcd4-3836-4d9d-b5e4-ec04efb220bc)
- [SQL injection](https://namu.wiki/w/SQL%20injection)
- [[Database] 정규화(Normalization) 쉽게 이해하기](https://mangkyu.tistory.com/110)
- [참조 무결성 및 Cascade](https://yusang.tistory.com/103)
